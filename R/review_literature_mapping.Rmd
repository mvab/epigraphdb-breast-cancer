---
title: "explore literature query output"
output: html_notebook
---


```{r message=F}
library(readr)
library(tidyr)
library(stringr)
library(vroom)
library(dplyr)

library(igraph)
library(networkD3)
```

```{r message=F}
dat<-vroom('../query_results/lit_bc_to_other_litterms.tsv')

keep_gwas<-c('ieu-a-1126','finn-a-C3_BREAST', 'finn-a-CD2_BENIGN_BREAST', 'ukb-a-519', 'ukb-d-C3_BREAST_3', 'ukb-d-D05') # can query with neo4j just for these

# check drug overlap with : https://www.cancer.gov/about-cancer/treatment/drugs/breast#3
bc_drugs <- read_tsv("external_files/breast_cancer_drug_list.tsv", col_names = c('name')) %>% distinct()

# load predicate direction
predicate_ref <- read_csv("external_files/predicates_direction.csv")
```

```{r}
dat %>% count(gwas.id, gwas.trait) 
```

```{r}
dat %>% select(st1.name) %>% distinct() %>% dim() #4550
dat %>% filter(gs1.pval<0.05) %>% select(st1.name) %>% distinct() %>% dim() #4524
hist(sort(dat$gs1.pval))
```

```{r}
dat %>% count(st1.name) %>% arrange(-n)
dat %>% select(gwas.id, gwas.trait, st1.name) %>% dim() #554663
dat %>% select(gwas.id, gwas.trait, st1.name) %>% distinct %>% dim() #89705 - unique terms that all gwas match
```


```{r}
# exploration of the matching difference between gwas
xx <- dat %>% filter(gwas.id %in% keep_gwas) %>% select(st1.name, st.name) 
xx<-c(xx$st1.name, xx$st.name) %>% unique()
length(xx)

yy <- dat %>% filter(!gwas.id %in% keep_gwas) %>% select(st1.name, st.name) 
yy<-c(yy$st1.name, yy$st.name) %>% unique()
length(yy)

diff <- setdiff(yy, xx)
length(diff) # 320 terms are not picked up by selected GWAS

# terms that are not included
dat %>% filter(st1.name %in% diff | st.name %in% diff) %>% count(gwas.id, gwas.trait) %>%  arrange(-n)

```

```{r}
bc_triples <- dat %>% filter(gwas.id %in% keep_gwas)


bc_triples_tidy <- 
  bc_triples %>% 
  select(-c('gwas.trait','gwas.id','gs1.pval' ,"s1.subject_id", "s1.id", "s1.object_id"  )) %>% 
  rename(term1 = st1.name,
         term2  = st.name,
         predicate = s1.predicate) %>% 
  # tidy up names
  mutate(term1 = gsub(" gene", "", term1)) %>% 
  mutate(term2 = gsub(" gene", "", term2)) %>% 
  mutate(term1 = gsub(" protein, human", "", term1)) %>% 
  mutate(term2 = gsub(" protein, human", "", term2)) %>% 
  mutate(term1 = gsub(", human", "", term1, ignore.case = T)) %>% 
  mutate(term2 = gsub(", human", "", term2, ignore.case = T)) %>% 
  distinct() %>% 
  filter(!(term2==term1)) 
  
dim(bc_triples_tidy) #26955

# if you subset the one above to 'Breast Diseases' in term2, will get same as melodi-presto query

```


```{r}
# add type to disease and drug nodes (selective)

node_types<-bind_rows(bc_triples_tidy %>% select(name = term1, type =st1.type),
                     bc_triples_tidy %>% select(name = term2, type = st.type)) %>% 
        mutate(type_verbose= case_when(type == "['dsyn']" ~ 'disease',
                                       type == "['orch']" ~ 'drug_or_compound',
                                       type == "['phsu']" ~ 'drug_or_compound',
                                       type == "['orch', 'phsu']" ~ 'drug_or_compound',
                                       type == "['hops']" ~ 'drug_or_compound',
                                       type == "['orch', 'phsu', 'hops']" ~ 'drug_or_compound',
                                       type == "['orch', 'hops']" ~ 'drug_or_compound',
                                       grepl('mab$',name) ~ 'drug_or_compound',
                                       grepl('cisplatin',name) ~ 'drug_or_compound',
                                       grepl('methotrexate polyglutamate',name) ~ 'drug_or_compound',
                                       grepl('herceptin',name) ~ 'drug_or_compound',
                                       TRUE ~ 'any'))

#node_types %>% count(type, sort=T) %>% View()

# find most common things
node_type_counts<-node_types %>% count(name, name='size', sort=T)
#node_type_counts %>% View()
common_nodes <- node_type_counts %>% filter(size > 310) %>% pull(name) # arbitary theshold

```

```{r}
# check which know BC drugs are in this dataset (imperfect matching approch WIP)
dim(bc_drugs)

length(intersect(node_type_counts$name, bc_drugs$name))#13
intersect(node_type_counts$name, bc_drugs$name)
length(setdiff( bc_drugs$name,node_type_counts$name))
setdiff( bc_drugs$name,node_type_counts$name)

node_types %>% filter(name %in% bc_drugs$name) %>% distinct %>% View()
```


*Network matching methods:*

* Forwards (2-level, 1 direction): term1 (set) -> term2 (many) -> term1 (many more)
* Backwards (2-level, 1 direction): term2 (many more) <- term 1 (many) <- term2 (set)

* F+B (1-level, 2 directions) : /[             \[ term1 /]-> term2  \]
                                /[  term1   <- \[ term2 /]          \]
                                
                                
* F+B pair ( two terms match + 1-level, 2 directions) :
        termX -> termY -> many 
many <- termX <- termY


*Additional network filters:*

- exclude neutral relationships
- exclude low count relationships (set threshold, default is 10)
- do not included rels from common nodes (e.g. estrogen - get a hairball right away)
- for 'rare' nodes - search the term in both term1 and term2 - use F+B


```{r}
select_network <- function(full_data, key_term, network_dir,
                           lowest_count_rel_to_keep = 10,
                           exclude_neutral = F, 
                           include_common_nodes_links = T, 
                           common_nodes = '', 
                           predicate_ref, 
                           rare_node = F){
  
if (network_dir != 'F+B pair'){
  if (length(key_term) > 1) {
    stop("this network type accepts only 1 key word")
  }
}
 
# select the direction of the network   
if (network_dir == 'forwards'){  
  data_level1<- full_data %>% filter(term1 == key_term) 
  data_level2<- full_data %>% filter(term1 %in% data_level1$term2) 
  
  data_megred <- bind_rows(data_level1, data_level2) %>% distinct()
  if (!include_common_nodes_links){
    print('removing rels of common nodes')
    data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
  }

} else if (network_dir == 'backwards'){  
  data_level1<- full_data %>% filter(term2 == key_term) 
  data_level2<- full_data %>% filter(term2 %in% data_level1$term1) 
  
  data_megred <- bind_rows(data_level1, data_level2) %>% distinct()
  if (include_common_nodes_links == F){
     print('removing rels of common nodes')
    data_megred<-data_megred %>% filter(!term2 %in% common_nodes)
  }
}  else if (network_dir == 'F+B 1-level'){ 
   data_dir1<- full_data %>% filter(term1 == key_term) 
   data_dir2<- full_data %>% filter(term2 == key_term) 
  
   data_megred <- bind_rows(data_dir1, data_dir2) %>% distinct()
   if (!include_common_nodes_links){
     print('removing rels of common nodes')
     data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
   }
}  else if (network_dir == 'F+B 2-level'){ 
   data_dir1_level1 <- full_data %>% filter(term1 == key_term) 
   data_dir1_level2 <- full_data %>% filter(term1 %in% data_dir1_level1$term2) 
   data_dir2_level1<- full_data %>% filter(term2 == key_term) 
   data_dir2_level2<- full_data %>% filter(term2 %in% data_dir2_level1$term1) 
  
   data_megred <- bind_rows(data_dir1_level1, data_dir1_level2, data_dir2_level1, data_dir2_level2) %>% distinct()
   
   if (!include_common_nodes_links){
     print('removing rels of common nodes')
     data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
   }

} else if (network_dir == 'F+B pair'){ 
  stopifnot(length(key_term) == 2)
  data_dir1<- full_data %>% filter(term1 %in% key_term) 
  data_dir2<- full_data %>% filter(term2 %in% key_term) 
  
  data_megred <- bind_rows(data_dir1, data_dir2) %>% distinct()
   if (!include_common_nodes_links){
     print('removing rels of common nodes')
     data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
   }
  
}  
  
# tidy data further

if (exclude_neutral){
   print('removing neutral relationships')
  data_megred <- data_megred %>%  filter(!predicate %in% c('COEXISTS_WITH', 'INTERACTS_WITH', 'ASSOCIATED_WITH')) 
}

data_megred_tidy<- data_megred %>% 
  select(term1, gs1.localCount, predicate, term2)  %>% 
  group_by(term1, predicate, term2) %>% 
  summarise(count = sum(gs1.localCount)) %>% 
  filter_by_count(., lowest_count_rel_to_keep, key_term, rare_node )%>%
  distinct() %>% 
  left_join(predicate_ref %>% select(predicate, direction), by = 'predicate') %>% 
  ungroup()

print(paste0("Rels in the network subset: ", dim(data_megred_tidy)[1]))

 return (data_megred_tidy)
}

filter_by_count <- function(dat, lowest_count_rel_to_keep, key_term='', rare_node=F){
  if (!rare_node){key_term=''}
  # if it's indicate that the key term is a rare node, we will keep all links for it, even below counts threshold
  keep_by_term<-dat %>% filter(term1 == key_term | term2 == key_term)
  keep_by_count<- dat %>% filter(count >= lowest_count_rel_to_keep)
  out<-bind_rows(keep_by_term, keep_by_count)
  return(out)
}


key_term = 'Insulin-Like Growth Factor I'
network_subset <-  select_network(full_data = bc_triples_tidy,
                                  #key_term = c("trastuzumab" ,"ERBB2"),
                                  key_term = key_term,
                                  network_dir = 'F+B 2-level',
                                  lowest_count_rel_to_keep = 10,
                                  exclude_neutral = F, 
                                  include_common_nodes_links = T, 
                                  common_nodes = common_nodes, 
                                  predicate_ref = predicate_ref,
                                  rare_node = F)


# count node frequency in network subset
node_counts<-bind_rows(network_subset %>% select(name = term1),
                       network_subset %>% select(name = term2)) %>% 
            count(name, name='size', sort=T) %>% 
            left_join(node_types %>% select(name, type_verbose) %>% distinct() , by = 'name') %>% 
            mutate(type_verbose = ifelse(name == key_term, 'key_term', type_verbose))

dim(node_counts)

```


```{r}
build_networkD3 <- function(network_subset, node_counts) {
  #http://curleylab.psych.columbia.edu/netviz/netviz2.html
  
  networkData <- data.frame(src = network_subset$term1,
                            target = network_subset$term2, 
                            rel_count = network_subset$count,
                            direction = network_subset$direction, 
                            stringsAsFactors = FALSE)
  direction <- network_subset$direction
  
  # make a nodes data frame out of all unique nodes in networkData
  nodes <- data.frame(name = unique(c(networkData$src, networkData$target)))
  
  # make a group variable where nodes in networkData$src are identified
  nodes$group <- nodes$name %in% networkData$src
  
  # add count how often it appers in network as size
  nodes<- nodes %>% left_join(node_counts, by='name') %>% select(-group) %>% rename('group' =  'type_verbose')
  
  # work out order of occurrence and set colors order
  node_cat_order <- data.frame(cat = node_counts$type_verbose[!duplicated(node_counts$type_verbose)])
  category_cols <- data.frame(cat = c("drug_or_compound", "disease", "key_term" , "any" ),
                              col = c("'#F2AD00'", "'#00A08A'", "'green'", "'black'"))
  cols_order <- left_join(node_cat_order, category_cols, by ='cat') %>% pull(col) %>% str_c(.,  collapse = ", ")
  JS_input <- str_c('d3.scaleOrdinal([',cols_order,']);') 
  
  # make a links data frame using the indexes (0-based) of nodes in 'nodes'
  links <- data.frame(source = match(networkData$src, nodes$name) - 1,
                      target = match(networkData$target, nodes$name) - 1)
  links$value <- networkData$rel_count/5
  
  
  b<-forceNetwork(Links = links, Nodes = nodes, Source = "source",
               Target = "target", NodeID ="name", Group = "group",
               opacity = 0.8, opacityNoHover = 0.5, zoom = T,
               #colourScale = ifelse(nodes[1,"group"] == 'drug_or_compound',
               #                               JS('d3.scaleOrdinal([ "#F2AD00" ,"black","#00A08A", "green"]);'),
               #                               JS('d3.scaleOrdinal([ "black","#F2AD00" ,"#00A08A", "green"]);')),
               colourScale = JS(JS_input),
               Value = 'value', arrows = T,
               Nodesize = 'size',
               charge = -2000, # node repulsion
               linkDistance = 25,
               fontSize=24,
               linkColour = ifelse(direction == 'positive', "#FF0000", 
                            ifelse(direction == 'negative', "#5BBCD6", 'black'))
               )
  return(b)
}
```


```{r}

b<-build_networkD3(network_subset, node_counts)
#htmlwidgets::saveWidget(b, file=paste0( getwd(), "/htmls/BRCA1_forwards_above10.html"))
```






```{r}
## check other GWAS quick
other_gwas<-vroom('../query_results/lit_ferritin_triples.tsv')
dim(other_gwas)

dim(bc_triples)

length(intersect(bc_triples$st.name, other_gwas$st1.name)) #245
View(intersect(bc_triples$st.name, other_gwas$st1.name))

```








```{r}

p <- simpleNetwork(test_merge1_simple, height="100px", width="100px",        
        Source = 1,                 # column number of source
        Target = 2,                 # column number of target
        linkDistance = 10,          # distance between node. Increase this value to have more space between nodes
        charge = -900,            # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
        fontSize = 14,               # size of the node names
        fontFamily = "serif",       # font og node names
        linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
        nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
        opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
        zoom = T                    # Can you zoom on the figure?
        )

# save the widget
# library(htmlwidgets)
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/networkInteractive2.html"))
```


