---
title: "explore literature query output"
output: html_notebook
---
  
  
```{r message=F}
library(readr)
library(tidyr)
library(stringr)
library(vroom)
library(dplyr)

library(igraph)
library(networkD3)
```

```{r message=F}
dat<-vroom('../query_results/lit_bc_to_other_litterms_upd.tsv') %>% mutate(lit.id = as.character(lit.id))


keep_gwas<-c('ieu-a-1126','finn-a-C3_BREAST', 'finn-a-CD2_BENIGN_BREAST', 'ukb-a-519', 'ukb-d-C3_BREAST_3', 'ukb-d-D05') # can query with neo4j just for these

# check drug overlap with : https://www.cancer.gov/about-cancer/treatment/drugs/breast#3
bc_drugs <- read_tsv("external_files/breast_cancer_drug_list.tsv", col_names = c('name')) %>% distinct()

# load predicate direction
predicate_ref <- read_csv("external_files/predicates_direction.csv")
```

```{r}
dat %>% count(gwas.id, gwas.trait) 
```


```{r}
dat %>% count(st1.name) %>% arrange(-n)
dat %>% select(gwas.id, gwas.trait, st1.name) %>% dim() #554663
dat %>% select(gwas.id, gwas.trait, st1.name) %>% distinct %>% dim() #89705 - unique terms that all gwas match
```


```{r}
# exploration of the matching difference between gwas
xx <- dat %>% filter(gwas.id %in% keep_gwas) %>% select(st1.name, st.name) 
xx<-c(xx$st1.name, xx$st.name) %>% unique()
length(xx)

yy <- dat %>% filter(!gwas.id %in% keep_gwas) %>% select(st1.name, st.name) 
yy<-c(yy$st1.name, yy$st.name) %>% unique()
length(yy)

diff <- setdiff(yy, xx)
length(diff) # 320 terms are not picked up by selected GWAS

# terms that are not included
dat %>% filter(st1.name %in% diff | st.name %in% diff) %>% count(gwas.id, gwas.trait) %>%  arrange(-n)

```

```{r}
bc_triples <- dat %>% filter(gwas.id %in% keep_gwas)

tidy_gwas_to_lit_output <- function(dat){  
  dat %>% 
    select(-c('gwas.trait','gwas.id','gs1.pval' ,"s1.subject_id", "s1.id", "s1.object_id"  )) %>% 
    rename(term1 = st1.name,
           term2  = st.name,
           predicate = s1.predicate) %>% 
    # tidy up names
    mutate(term1 = gsub(" gene", "", term1)) %>% 
    mutate(term2 = gsub(" gene", "", term2)) %>% 
    mutate(term1 = gsub(" protein, human", "", term1)) %>% 
    mutate(term2 = gsub(" protein, human", "", term2)) %>% 
    mutate(term1 = gsub(", human", "", term1, ignore.case = T)) %>% 
    mutate(term2 = gsub(", human", "", term2, ignore.case = T)) %>% 
    distinct() %>% 
    filter(!(term2==term1)) 
}  

bc_triples_tidy <- tidy_gwas_to_lit_output(bc_triples)

dim(bc_triples_tidy) #31350

# if you subset the one above to 'Breast Diseases' in term2, will get same as melodi-presto query

```


```{r}
# add type to disease and drug nodes (selective)

node_types<-bind_rows(bc_triples_tidy %>% select(name = term1, type =st1.type),
                      bc_triples_tidy %>% select(name = term2, type = st.type)) %>% 
  mutate(type_verbose= case_when(type == "['dsyn']" ~ 'disease',
                                 type == "['orch']" ~ 'drug_or_compound',
                                 type == "['phsu']" ~ 'drug_or_compound',
                                 type == "['orch', 'phsu']" ~ 'drug_or_compound',
                                 type == "['hops']" ~ 'drug_or_compound',
                                 type == "['orch', 'phsu', 'hops']" ~ 'drug_or_compound',
                                 type == "['orch', 'hops']" ~ 'drug_or_compound',
                                 grepl('mab$',name) ~ 'drug_or_compound',
                                 grepl('cisplatin',name) ~ 'drug_or_compound',
                                 grepl('methotrexate polyglutamate',name) ~ 'drug_or_compound',
                                 grepl('herceptin',name) ~ 'drug_or_compound',
                                 grepl('fulvestrant',name) ~ 'drug_or_compound',
                                 grepl('capecitabine',name) ~ 'drug_or_compound',
                                 grepl('fluorouracil',name) ~ 'drug_or_compound',
                                 grepl('cyclophosphamide',name) ~ 'drug_or_compound',
                                 grepl('exemestane',name) ~ 'drug_or_compound',
                                  grepl('ado-trastuzumab emtansine',name) ~ 'drug_or_compound',
                                  grepl('megestrol acetate',name) ~ 'drug_or_compound',
                                  grepl('thiotepa',name) ~ 'drug_or_compound',
                                 TRUE ~ 'any'))

#node_types %>% count(type, sort=T) %>% View()

# find most common things
node_type_counts<-node_types %>% count(name, name='size', sort=T)
#node_type_counts %>% View()
common_nodes <- node_type_counts %>% filter(size > 300) %>% pull(name) # arbitary theshold

```

```{r}
# check which know BC drugs are in this dataset (imperfect matching approch WIP)
dim(bc_drugs)

length(intersect(node_type_counts$name, bc_drugs$name))#22
intersect(node_type_counts$name, bc_drugs$name)
length(setdiff( bc_drugs$name,node_type_counts$name))
setdiff( bc_drugs$name,node_type_counts$name)

node_types %>% filter(name %in% bc_drugs$name) %>% distinct %>% View()
```


*Network matching methods:*
  
  * Forwards (2-level, 1 direction): term1 (set) -> term2 (many) -> term1 (many more)
* Backwards (2-level, 1 direction): term2 (many more) <- term 1 (many) <- term2 (set)

* F+B (1-level, 2 directions) : /[             \[ term1 /]-> term2  \]
/[  term1   <- \[ term2 /]          \]


* F+B pair ( two terms match + 1-level, 2 directions) :
  termX -> termY -> many 
many <- termX <- termY


*Additional network filters:*
  
  - exclude neutral relationships
- exclude low count relationships (set threshold, default is 10)
- do not included rels from common nodes (e.g. estrogen - get a hairball right away)
- for 'rare' nodes - search the term in both term1 and term2 - use F+B


```{r}
select_network <- function(full_data, key_term, network_dir,
                           lowest_count_rel_to_keep = 10,
                           exclude_neutral = F, 
                           include_common_nodes_links = T, 
                           common_nodes = '', 
                           predicate_ref, 
                           rare_node = F){
  
  if (!network_dir %in% c('F+B pair', 'F+B multiple') ){
    if (length(key_term) > 1) {
      stop("this network type accepts only 1 key word")
    }
  }
  
  # select the direction of the network   
  if (network_dir == 'forwards'){  
    data_level1<- full_data %>% filter(term1 == key_term) 
    data_level2<- full_data %>% filter(term1 %in% data_level1$term2) 
    
    data_megred <- bind_rows(data_level1, data_level2) %>% distinct()
    if (!include_common_nodes_links){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
    }
    
  } else if (network_dir == 'backwards'){  
    data_level1<- full_data %>% filter(term2 == key_term) 
    data_level2<- full_data %>% filter(term2 %in% data_level1$term1) 
    
    data_megred <- bind_rows(data_level1, data_level2) %>% distinct()
    if (include_common_nodes_links == F){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term2 %in% common_nodes)
    }
  }  else if (network_dir == 'F+B 1-level'){ 
    data_dir1<- full_data %>% filter(term1 == key_term) 
    data_dir2<- full_data %>% filter(term2 == key_term) 
    
    data_megred <- bind_rows(data_dir1, data_dir2) %>% distinct()
    if (!include_common_nodes_links){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
    }
  }  else if (network_dir == 'F+B 2-level'){ 
    data_dir1_level1 <- full_data %>% filter(term1 == key_term) 
    data_dir1_level2 <- full_data %>% filter(term1 %in% data_dir1_level1$term2) 
    data_dir2_level1<- full_data %>% filter(term2 == key_term) 
    data_dir2_level2<- full_data %>% filter(term2 %in% data_dir2_level1$term1) 
    
    data_megred <- bind_rows(data_dir1_level1, data_dir1_level2, data_dir2_level1, data_dir2_level2) %>% distinct()
    
    if (!include_common_nodes_links){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
    }
    
  } else if (network_dir == 'F+B pair'){ 
    stopifnot(length(key_term) == 2)
    data_dir1<- full_data %>% filter(term1 %in% key_term) 
    data_dir2<- full_data %>% filter(term2 %in% key_term) 
    
    data_megred <- bind_rows(data_dir1, data_dir2) %>% distinct()
    if (!include_common_nodes_links){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
  }
  } else if (network_dir == 'F+B multiple'){ 
    stopifnot(length(key_term) >= 2)
    data_dir1<- full_data %>% filter(term1 %in% key_term) 
    data_dir2<- full_data %>% filter(term2 %in% key_term) 
    
    data_megred <- bind_rows(data_dir1, data_dir2) %>% distinct()
    if (!include_common_nodes_links){
      print('removing rels of common nodes')
      data_megred<-data_megred %>% filter(!term1 %in% common_nodes)
    }
  }  
    
  
  
  # tidy data further
  
  if (exclude_neutral){
    print('removing neutral relationships')
    data_megred <- data_megred %>%  filter(!predicate %in% c('COEXISTS_WITH', 'INTERACTS_WITH', 'ASSOCIATED_WITH')) 
  }
  
  data_megred_tidy<- data_megred %>% 
    select(term1, gs1.localCount, predicate, term2)  %>% 
    group_by(term1, predicate, term2) %>% 
    summarise(count = sum(gs1.localCount)) %>% 
    filter_by_count(., lowest_count_rel_to_keep, key_term, rare_node )%>%
    distinct() %>% 
    left_join(predicate_ref %>% select(predicate, direction), by = 'predicate') %>% 
    ungroup()
  
  print(paste0("Rels in the network subset: ", dim(data_megred_tidy)[1]))
  
  return (data_megred_tidy)
}

filter_by_count <- function(dat, lowest_count_rel_to_keep, key_term='', rare_node=F){
  if (!rare_node){key_term=''}
  # if it's indicate that the key term is a rare node, we will keep all links for it, even below counts threshold
  keep_by_term<-dat %>% filter(term1 %in% key_term | term2 %in% key_term)
  keep_by_count<- dat %>% filter(count >= lowest_count_rel_to_keep)
  out<-bind_rows(keep_by_term, keep_by_count)
  return(out)
}


key_term = 'Cyclin D1'
#key_term <- node_type_counts$name[grepl("statin", node_type_counts$name)]
network_subset <-  select_network(full_data = bc_triples_tidy,
                                  #key_term = c("trastuzumab" ,"ERBB2"),
                                  key_term = key_term,
                                  network_dir = 'forwards',
                                  lowest_count_rel_to_keep = 10,
                                  exclude_neutral = T, 
                                  include_common_nodes_links = T, 
                                  common_nodes = common_nodes, 
                                  predicate_ref = predicate_ref,
                                  rare_node = F)


# count node frequency in network subset
node_counts<-bind_rows(network_subset %>% select(name = term1),
                       network_subset %>% select(name = term2)) %>% 
  count(name, name='size', sort=T) %>% 
  left_join(node_types %>% select(name, type_verbose) %>% distinct() , by = 'name') %>% 
  mutate(type_verbose = ifelse(name == key_term, 'key_term', type_verbose))

dim(node_counts)

```


```{r}
build_networkD3 <- function(network_subset, node_counts) {
  #http://curleylab.psych.columbia.edu/netviz/netviz2.html
  
  networkData <- data.frame(src = network_subset$term1,
                            target = network_subset$term2, 
                            rel_count = network_subset$count,
                            direction = network_subset$direction, 
                            stringsAsFactors = FALSE)
  direction <- network_subset$direction
  
  # make a nodes data frame out of all unique nodes in networkData
  nodes <- data.frame(name = unique(c(networkData$src, networkData$target)))
  
  # make a group variable where nodes in networkData$src are identified
  nodes$group <- nodes$name %in% networkData$src
  
  # add count how often it appers in network as size
  nodes<- nodes %>% left_join(node_counts, by='name') %>% select(-group) %>% rename('group' =  'type_verbose')
  
  # work out order of occurrence and set colors order
  node_cat_order <- data.frame(cat = nodes$group[!duplicated(nodes$group)])
  category_cols <- data.frame(cat = c("drug_or_compound", "disease", "key_term" , "any" ),
                              col = c("'#F2AD00'", "'#00A08A'", "'green'", "'black'"))
  cols_order <- left_join(node_cat_order, category_cols, by ='cat') %>% pull(col) %>% str_c(.,  collapse = ", ")
  JS_input <- str_c('d3.scaleOrdinal([',cols_order,']);') 
  if(is.na(JS_input)) {JS_input <- "d3.scaleOrdinal(['green','black']);" }
  
  # make a links data frame using the indexes (0-based) of nodes in 'nodes'
  links <- data.frame(source = match(networkData$src, nodes$name) - 1,
                      target = match(networkData$target, nodes$name) - 1)
  links$value <- networkData$rel_count/5
  
  
  b<-forceNetwork(Links = links, Nodes = nodes, Source = "source",
                  Target = "target", NodeID ="name", Group = "group",
                  opacity = 0.8, opacityNoHover = 0.5, zoom = T,
                  #colourScale = ifelse(nodes[1,"group"] == 'drug_or_compound',
                  #                               JS('d3.scaleOrdinal([ "#F2AD00" ,"black","#00A08A", "green"]);'),
                  #                               JS('d3.scaleOrdinal([ "black","#F2AD00" ,"#00A08A", "green"]);')),
                  colourScale = JS(JS_input),
                  Value = 'value', arrows = T,
                  Nodesize = 'size',
                  charge = -1000, # node repulsion
                  linkDistance = 25,
                  fontSize=24,
                  linkColour = ifelse(direction == 'positive', "#FF0000", 
                                      ifelse(direction == 'negative', "#5BBCD6", 'black'))
  )
  return(b)
}
```


```{r}

b<-build_networkD3(network_subset, node_counts)
#htmlwidgets::saveWidget(b, file=paste0( getwd(), "/htmls/cyclinD1_backwards.html"))
```






```{r}
## check other GWAS quick
other_gwas<-vroom('../query_results/lit_childhood_obesity_triples.tsv')
dim(other_gwas)

dim(bc_triples)

# X -> Y, where X is BC
length(intersect(bc_triples$st.name, other_gwas$st1.name)) #245
View(intersect(bc_triples$st.name, other_gwas$st1.name))

# Y -> X , where X is BC
length(intersect(other_gwas$st.name, bc_triples$st1.name)) #175
View(intersect(other_gwas$st.name, bc_triples$st1.name))
```

```{r}
other_gwas_tidy<-tidy_gwas_to_lit_output(other_gwas)
bc_triples_tidy

# overlap Y -> X

overlap1 <- intersect( other_gwas_tidy$term2, bc_triples_tidy$term1)
overlap1_merged<-bind_rows(other_gwas_tidy %>% filter(term2 %in% overlap1),
                           bc_triples_tidy %>% filter(term1 %in% overlap1) %>% 
                                             filter(!predicate %in% c('COEXISTS_WITH', 'INTERACTS_WITH', 'ASSOCIATED_WITH'))) %>% 
                          # other_gwas_tidy %>% filter(grepl("ICOS|Inducible",term2) | grepl("ICOS|Inducible",term1))) %>% 
  select(term1, gs1.localCount, predicate, term2)  %>% 
  filter(gs1.localCount >= 2) %>% 
  group_by(term1, predicate, term2) %>% 
  summarise(count = sum(gs1.localCount)) %>%
  distinct() %>% 
  left_join(predicate_ref %>% select(predicate, direction), by = 'predicate') %>% 
  ungroup() %>% 
  filter(!term1 %in% c(common_nodes, 'Obesity'), term2 != 'Obesity')
  #filter(!predicate %in% c('COEXISTS_WITH', 'INTERACTS_WITH', 'ASSOCIATED_WITH')) 
dim(overlap1_merged)

node_counts<-bind_rows(overlap1_merged %>% select(name = term1),
                       overlap1_merged %>% select(name = term2)) %>% 
  count(name, name='size', sort=T) %>% 
  mutate(type_verbose = ifelse(name %in% overlap1, 'overlap', 'other'))

dim(node_counts)

c<-build_networkD3(overlap1_merged, node_counts)

#htmlwidgets::saveWidget(c, file=paste0( getwd(), "/htmls/bc_w_childhoodobesity.html"))
```














```{r}

p <- simpleNetwork(test_merge1_simple, height="100px", width="100px",        
                   Source = 1,                 # column number of source
                   Target = 2,                 # column number of target
                   linkDistance = 10,          # distance between node. Increase this value to have more space between nodes
                   charge = -900,            # numeric value indicating either the strength of the node repulsion (negative value) or attraction (positive value)
                   fontSize = 14,               # size of the node names
                   fontFamily = "serif",       # font og node names
                   linkColour = "#666",        # colour of edges, MUST be a common colour for the whole graph
                   nodeColour = "#69b3a2",     # colour of nodes, MUST be a common colour for the whole graph
                   opacity = 0.9,              # opacity of nodes. 0=transparent. 1=no transparency
                   zoom = T                    # Can you zoom on the figure?
)

# save the widget
# library(htmlwidgets)
# saveWidget(p, file=paste0( getwd(), "/HtmlWidget/networkInteractive2.html"))
```


